package mtw

import mtw.Region.Companion.predefinedRegions

val campaignMap = """
1234567890123456789   
___________________
| x G   #       x |
|   #     x x     |
|   x    x  ....# |
|  x     G  . x   |
|       x #..x   #|
| #  x       x    |
| x       x     G |
| #............# x|
|_________________|
1234567890123456789
""".trimIndent()

/*
| и _ - границы карты
x - места, куда нельзя пройти (горы, реки)
# - города
G - генералы фракций
. - дорога
 */

val coordinatesMap = campaignMap.split("\n").mapIndexed { y, line ->
    /*
    campaignMap.split("\n") - разбивает строку campaignMap на массив строк, используя разделитель \n (перевод строки).
    Этот метод возвращает массив строк, где каждая строка представляет одну строку абстрактной карты.
    mapIndexed { y, line -> ... } выполняет функцию для каждого элемента массива строк и его индекса.
    Функция принимает два параметра: y - индекс текущей строки, и line - сама строка.
     */
    line.mapIndexed { x, c ->
        /*
        line.mapIndexed { x, c -> ... } используется для итерации по каждому символу в строке и выполнения некоторой
        логики для каждого символа.
        line - это коллекция строк, которая содержит строки, разделенные пробелом.
        mapIndexed - это функция, которая применяется к коллекции строк и выполняет некоторую логику для каждого
        элемента коллекции. Она принимает два параметра:
        x - индекс текущего элемента в коллекции.
        c - текущий элемент коллекции (символ строки).
        Для каждого символа строки проверяется наличие символа #. Если символ # найден, выполняется поиск
        соответствующего региона в предопределенных регионах с помощью RegionName.values().find { ... }. Если регион
        найден, его координаты добавляются в массив координат coordinates объекта Region.
        Таким образом, line.mapIndexed { x, c -> ... } используется для преобразования символов строк в коллекции line
        в координаты для объектов Region.
         */
        if (c == '#') {
            /*
            Этот код используется для поиска соответствующего региона на абстрактной карте для каждого символа
            # в строке.
            Проверяется, является ли текущий символ # (c == #). Если символ не равен #, возвращается null.
            Если символ равен #, запускается поиск соответствующего региона в предопределенных регионах
            (RegionName.values().find { ... })
             */
            RegionName.values().find { region ->
                /*
                В этом коде используется функция find для поиска первого элемента в коллекции RegionName.values(),
                который удовлетворяет условию внутри лямбда-выражения { region -> ... }.
                RegionName.values() возвращает список всех элементов перечисления RegionName.
                find { ... } вызывается для этого списка и ищет первый элемент, который удовлетворяет условию
                внутри лямбда-выражения.
                Внутри лямбда-выражения { region -> ... }, проверяется условие для каждого региона region (Параметр
                region представляет текущий элемент из коллекции, и лямбда-выражение проверяет условие для этого элемента
                из RegionName.values().
                Если условие удовлетворяется, функция find возвращает соответствующий регион.
                Если условие не удовлетворяется ни для одного региона, функция find возвращает null.
                Таким образом, RegionName.values().find { ... } используется для поиска первого региона,
                удовлетворяющего условию внутри лямбда-выражения.
                 */
                predefinedRegions[region]?.coordinates?.x == x && predefinedRegions[region]?.coordinates?.y == y
                /*
                1. predefinedRegions[region] - это попытка получить объект региона из массива predefinedRegions по
                ключу region. Если регион не найден, то возвращается null.
                2. coordinates?.x - это попытка получить значение x из свойства coordinates объекта региона. Если
                объект региона равен null, то возвращается null.
                3. == x - это сравнение значения x с результатом предыдущего выражения. Если результат предыдущего
                выражения был null, то сравнение не выполняется и возвращается null.
                4. Аналогично, predefinedRegions[region]?.coordinates?.y пытается получить значение y из свойства
                coordinates объекта региона.
                5. == y - это сравнение значения y с результатом предыдущего выражения. Если результат предыдущего
                выражения был null, то сравнение не выполняется и возвращается null.
                6. && - это оператор логического И, который возвращает true, если оба его операнда равны true, и false
                в противном случае. Если хотя бы одно из условий predefinedRegions[region]?.coordinates?.x == x или
                predefinedRegions[region]?.coordinates?.y == y возвращает null, то выражение && вернет false.

                Таким образом, этот код проверяет, соответствуют ли координаты региона x и y заданным значениям, и
                возвращает true, если оба условия истинны, и false в противном случае. Если регион не найден в массиве
                predefinedRegions, то выражение вернет false.
                 */
            }
        } else {
            null
        }
    }
}.dropLast(1)

var move = 1
fun startCampaign() {
    println("You choosed: ${userChoice!!.factionName}")
    println(
        "Purse: ${
            Faction.predefinedFactions[userChoice]?.purse
        }"
    )
    println("****************")
    println("The computer will play as:")
    computerChoices.forEach { factionComputer ->
        Faction.predefinedFactions[factionComputer]?.let {
            println("${it.name} \nPurse: ${it.purse}\n****************")
        }
    }
    /*
forEach - это функция высшего порядка (higher-order function), которая выполняет указанное действие для
каждого элемента списка.
factionComputer - это переменная, которая используется в качестве параметра для лямбда-выражения в коде.
В данном контексте factionComputer представляет собой каждый элемент списка computerChoices, который перебирается
в цикле forEach. То есть, на каждой итерации цикла factionComputer будет ссылаться на текущий элемент списка
computerChoices. В данном коде factionComputer используется для доступа к объекту Faction из предопределенного
списка фракций и вывода информации о нем.

Faction.predefinedFactions[factionComputer]: Этот код получает значение типа Faction? (фракции) из списка
предопределенных фракций по ключу factionComputer.
Метод predefinedFactions возвращает фракцию (Faction), соответствующую ключу factionComputer.

?.let { ... }: Это оператор безопасного вызова (safe call operator). Он позволяет безопасно
вызывать методы или обращаться к свойствам объекта, проверяя наличие значения объекта перед обращением к
нему. Если значение объекта не является null, то выполняется блок кода внутри let, где it представляет
собой полученный объект. Если значение объекта равно null, то блок кода внутри let не выполняется.
*/
    while (true) {
        println("Move No. $move")
        println(campaignMap)
        when (readln()) {
            "1" -> step1()
            "n" -> {
                move++
            }

            "" -> return
            else -> println("Error. Please enter a valid value")
        }
    }
}
